// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mockstorage

import (
	"context"
	"io"
	"sync"

	"github.com/oneconcern/datamon/pkg/storage"
)

var (
	lockStoreMockClear      sync.RWMutex
	lockStoreMockDelete     sync.RWMutex
	lockStoreMockGet        sync.RWMutex
	lockStoreMockGetAt      sync.RWMutex
	lockStoreMockGetAttr    sync.RWMutex
	lockStoreMockHas        sync.RWMutex
	lockStoreMockKeys       sync.RWMutex
	lockStoreMockKeysPrefix sync.RWMutex
	lockStoreMockPut        sync.RWMutex
	lockStoreMockString     sync.RWMutex
	lockStoreMockTouch      sync.RWMutex
)

// Ensure, that StoreMock does implement Store.
// If this is not the case, regenerate this file with moq.
var _ storage.Store = &StoreMock{}

// StoreMock is a mock implementation of Store.
//
//     func TestSomethingThatUsesStore(t *testing.T) {
//
//         // make and configure a mocked Store
//         mockedStore := &StoreMock{
//             ClearFunc: func(in1 context.Context) error {
// 	               panic("mock out the Clear method")
//             },
//             DeleteFunc: func(in1 context.Context, in2 string) error {
// 	               panic("mock out the Delete method")
//             },
//             GetFunc: func(in1 context.Context, in2 string) (io.ReadCloser, error) {
// 	               panic("mock out the Get method")
//             },
//             GetAtFunc: func(in1 context.Context, in2 string) (io.ReaderAt, error) {
// 	               panic("mock out the GetAt method")
//             },
//             GetAttrFunc: func(in1 context.Context, in2 string) (storage.Attributes, error) {
// 	               panic("mock out the GetAttr method")
//             },
//             HasFunc: func(in1 context.Context, in2 string) (bool, error) {
// 	               panic("mock out the Has method")
//             },
//             KeysFunc: func(in1 context.Context) ([]string, error) {
// 	               panic("mock out the Keys method")
//             },
//             KeysPrefixFunc: func(ctx context.Context, pageToken string, prefix string, delimiter string, count int) ([]string, string, error) {
// 	               panic("mock out the KeysPrefix method")
//             },
//             PutFunc: func(in1 context.Context, in2 string, in3 io.Reader, in4 storage.NewKey) error {
// 	               panic("mock out the Put method")
//             },
//             StringFunc: func() string {
// 	               panic("mock out the String method")
//             },
//             TouchFunc: func(in1 context.Context, in2 string) error {
// 	               panic("mock out the Touch method")
//             },
//         }
//
//         // use mockedStore in code that requires Store
//         // and then make assertions.
//
//     }
type StoreMock struct {
	// ClearFunc mocks the Clear method.
	ClearFunc func(in1 context.Context) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(in1 context.Context, in2 string) error

	// GetFunc mocks the Get method.
	GetFunc func(in1 context.Context, in2 string) (io.ReadCloser, error)

	// GetAtFunc mocks the GetAt method.
	GetAtFunc func(in1 context.Context, in2 string) (io.ReaderAt, error)

	// GetAttrFunc mocks the GetAttr method.
	GetAttrFunc func(in1 context.Context, in2 string) (storage.Attributes, error)

	// HasFunc mocks the Has method.
	HasFunc func(in1 context.Context, in2 string) (bool, error)

	// KeysFunc mocks the Keys method.
	KeysFunc func(in1 context.Context) ([]string, error)

	// KeysPrefixFunc mocks the KeysPrefix method.
	KeysPrefixFunc func(ctx context.Context, pageToken string, prefix string, delimiter string, count int) ([]string, string, error)

	// PutFunc mocks the Put method.
	PutFunc func(in1 context.Context, in2 string, in3 io.Reader, in4 storage.NewKey) error

	// StringFunc mocks the String method.
	StringFunc func() string

	// TouchFunc mocks the Touch method.
	TouchFunc func(in1 context.Context, in2 string) error

	// calls tracks calls to the methods.
	calls struct {
		// Clear holds details about calls to the Clear method.
		Clear []struct {
			// In1 is the in1 argument value.
			In1 context.Context
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
		}
		// GetAt holds details about calls to the GetAt method.
		GetAt []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
		}
		// GetAttr holds details about calls to the GetAttr method.
		GetAttr []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
		}
		// Has holds details about calls to the Has method.
		Has []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
		}
		// Keys holds details about calls to the Keys method.
		Keys []struct {
			// In1 is the in1 argument value.
			In1 context.Context
		}
		// KeysPrefix holds details about calls to the KeysPrefix method.
		KeysPrefix []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PageToken is the pageToken argument value.
			PageToken string
			// Prefix is the prefix argument value.
			Prefix string
			// Delimiter is the delimiter argument value.
			Delimiter string
			// Count is the count argument value.
			Count int
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
			// In3 is the in3 argument value.
			In3 io.Reader
			// In4 is the in4 argument value.
			In4 storage.NewKey
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Touch holds details about calls to the Touch method.
		Touch []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 string
		}
	}
}

// Clear calls ClearFunc.
func (mock *StoreMock) Clear(in1 context.Context) error {
	if mock.ClearFunc == nil {
		panic("StoreMock.ClearFunc: method is nil but Store.Clear was just called")
	}
	callInfo := struct {
		In1 context.Context
	}{
		In1: in1,
	}
	lockStoreMockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	lockStoreMockClear.Unlock()
	return mock.ClearFunc(in1)
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//     len(mockedStore.ClearCalls())
func (mock *StoreMock) ClearCalls() []struct {
	In1 context.Context
} {
	var calls []struct {
		In1 context.Context
	}
	lockStoreMockClear.RLock()
	calls = mock.calls.Clear
	lockStoreMockClear.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *StoreMock) Delete(in1 context.Context, in2 string) error {
	if mock.DeleteFunc == nil {
		panic("StoreMock.DeleteFunc: method is nil but Store.Delete was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
	}{
		In1: in1,
		In2: in2,
	}
	lockStoreMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockStoreMockDelete.Unlock()
	return mock.DeleteFunc(in1, in2)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedStore.DeleteCalls())
func (mock *StoreMock) DeleteCalls() []struct {
	In1 context.Context
	In2 string
} {
	var calls []struct {
		In1 context.Context
		In2 string
	}
	lockStoreMockDelete.RLock()
	calls = mock.calls.Delete
	lockStoreMockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *StoreMock) Get(in1 context.Context, in2 string) (io.ReadCloser, error) {
	if mock.GetFunc == nil {
		panic("StoreMock.GetFunc: method is nil but Store.Get was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
	}{
		In1: in1,
		In2: in2,
	}
	lockStoreMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockStoreMockGet.Unlock()
	return mock.GetFunc(in1, in2)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedStore.GetCalls())
func (mock *StoreMock) GetCalls() []struct {
	In1 context.Context
	In2 string
} {
	var calls []struct {
		In1 context.Context
		In2 string
	}
	lockStoreMockGet.RLock()
	calls = mock.calls.Get
	lockStoreMockGet.RUnlock()
	return calls
}

// GetAt calls GetAtFunc.
func (mock *StoreMock) GetAt(in1 context.Context, in2 string) (io.ReaderAt, error) {
	if mock.GetAtFunc == nil {
		panic("StoreMock.GetAtFunc: method is nil but Store.GetAt was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
	}{
		In1: in1,
		In2: in2,
	}
	lockStoreMockGetAt.Lock()
	mock.calls.GetAt = append(mock.calls.GetAt, callInfo)
	lockStoreMockGetAt.Unlock()
	return mock.GetAtFunc(in1, in2)
}

// GetAtCalls gets all the calls that were made to GetAt.
// Check the length with:
//     len(mockedStore.GetAtCalls())
func (mock *StoreMock) GetAtCalls() []struct {
	In1 context.Context
	In2 string
} {
	var calls []struct {
		In1 context.Context
		In2 string
	}
	lockStoreMockGetAt.RLock()
	calls = mock.calls.GetAt
	lockStoreMockGetAt.RUnlock()
	return calls
}

// GetAttr calls GetAttrFunc.
func (mock *StoreMock) GetAttr(in1 context.Context, in2 string) (storage.Attributes, error) {
	if mock.GetAttrFunc == nil {
		panic("StoreMock.GetAttrFunc: method is nil but Store.GetAttr was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
	}{
		In1: in1,
		In2: in2,
	}
	lockStoreMockGetAttr.Lock()
	mock.calls.GetAttr = append(mock.calls.GetAttr, callInfo)
	lockStoreMockGetAttr.Unlock()
	return mock.GetAttrFunc(in1, in2)
}

// GetAttrCalls gets all the calls that were made to GetAttr.
// Check the length with:
//     len(mockedStore.GetAttrCalls())
func (mock *StoreMock) GetAttrCalls() []struct {
	In1 context.Context
	In2 string
} {
	var calls []struct {
		In1 context.Context
		In2 string
	}
	lockStoreMockGetAttr.RLock()
	calls = mock.calls.GetAttr
	lockStoreMockGetAttr.RUnlock()
	return calls
}

// Has calls HasFunc.
func (mock *StoreMock) Has(in1 context.Context, in2 string) (bool, error) {
	if mock.HasFunc == nil {
		panic("StoreMock.HasFunc: method is nil but Store.Has was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
	}{
		In1: in1,
		In2: in2,
	}
	lockStoreMockHas.Lock()
	mock.calls.Has = append(mock.calls.Has, callInfo)
	lockStoreMockHas.Unlock()
	return mock.HasFunc(in1, in2)
}

// HasCalls gets all the calls that were made to Has.
// Check the length with:
//     len(mockedStore.HasCalls())
func (mock *StoreMock) HasCalls() []struct {
	In1 context.Context
	In2 string
} {
	var calls []struct {
		In1 context.Context
		In2 string
	}
	lockStoreMockHas.RLock()
	calls = mock.calls.Has
	lockStoreMockHas.RUnlock()
	return calls
}

// Keys calls KeysFunc.
func (mock *StoreMock) Keys(in1 context.Context) ([]string, error) {
	if mock.KeysFunc == nil {
		panic("StoreMock.KeysFunc: method is nil but Store.Keys was just called")
	}
	callInfo := struct {
		In1 context.Context
	}{
		In1: in1,
	}
	lockStoreMockKeys.Lock()
	mock.calls.Keys = append(mock.calls.Keys, callInfo)
	lockStoreMockKeys.Unlock()
	return mock.KeysFunc(in1)
}

// KeysCalls gets all the calls that were made to Keys.
// Check the length with:
//     len(mockedStore.KeysCalls())
func (mock *StoreMock) KeysCalls() []struct {
	In1 context.Context
} {
	var calls []struct {
		In1 context.Context
	}
	lockStoreMockKeys.RLock()
	calls = mock.calls.Keys
	lockStoreMockKeys.RUnlock()
	return calls
}

// KeysPrefix calls KeysPrefixFunc.
func (mock *StoreMock) KeysPrefix(ctx context.Context, pageToken string, prefix string, delimiter string, count int) ([]string, string, error) {
	if mock.KeysPrefixFunc == nil {
		panic("StoreMock.KeysPrefixFunc: method is nil but Store.KeysPrefix was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		PageToken string
		Prefix    string
		Delimiter string
		Count     int
	}{
		Ctx:       ctx,
		PageToken: pageToken,
		Prefix:    prefix,
		Delimiter: delimiter,
		Count:     count,
	}
	lockStoreMockKeysPrefix.Lock()
	mock.calls.KeysPrefix = append(mock.calls.KeysPrefix, callInfo)
	lockStoreMockKeysPrefix.Unlock()
	return mock.KeysPrefixFunc(ctx, pageToken, prefix, delimiter, count)
}

// KeysPrefixCalls gets all the calls that were made to KeysPrefix.
// Check the length with:
//     len(mockedStore.KeysPrefixCalls())
func (mock *StoreMock) KeysPrefixCalls() []struct {
	Ctx       context.Context
	PageToken string
	Prefix    string
	Delimiter string
	Count     int
} {
	var calls []struct {
		Ctx       context.Context
		PageToken string
		Prefix    string
		Delimiter string
		Count     int
	}
	lockStoreMockKeysPrefix.RLock()
	calls = mock.calls.KeysPrefix
	lockStoreMockKeysPrefix.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *StoreMock) Put(in1 context.Context, in2 string, in3 io.Reader, in4 storage.NewKey) error {
	if mock.PutFunc == nil {
		panic("StoreMock.PutFunc: method is nil but Store.Put was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
		In3 io.Reader
		In4 storage.NewKey
	}{
		In1: in1,
		In2: in2,
		In3: in3,
		In4: in4,
	}
	lockStoreMockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	lockStoreMockPut.Unlock()
	return mock.PutFunc(in1, in2, in3, in4)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//     len(mockedStore.PutCalls())
func (mock *StoreMock) PutCalls() []struct {
	In1 context.Context
	In2 string
	In3 io.Reader
	In4 storage.NewKey
} {
	var calls []struct {
		In1 context.Context
		In2 string
		In3 io.Reader
		In4 storage.NewKey
	}
	lockStoreMockPut.RLock()
	calls = mock.calls.Put
	lockStoreMockPut.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *StoreMock) String() string {
	if mock.StringFunc == nil {
		panic("StoreMock.StringFunc: method is nil but Store.String was just called")
	}
	callInfo := struct {
	}{}
	lockStoreMockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	lockStoreMockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//     len(mockedStore.StringCalls())
func (mock *StoreMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	lockStoreMockString.RLock()
	calls = mock.calls.String
	lockStoreMockString.RUnlock()
	return calls
}

// Touch calls TouchFunc.
func (mock *StoreMock) Touch(in1 context.Context, in2 string) error {
	if mock.TouchFunc == nil {
		panic("StoreMock.TouchFunc: method is nil but Store.Touch was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 string
	}{
		In1: in1,
		In2: in2,
	}
	lockStoreMockTouch.Lock()
	mock.calls.Touch = append(mock.calls.Touch, callInfo)
	lockStoreMockTouch.Unlock()
	return mock.TouchFunc(in1, in2)
}

// TouchCalls gets all the calls that were made to Touch.
// Check the length with:
//     len(mockedStore.TouchCalls())
func (mock *StoreMock) TouchCalls() []struct {
	In1 context.Context
	In2 string
} {
	var calls []struct {
		In1 context.Context
		In2 string
	}
	lockStoreMockTouch.RLock()
	calls = mock.calls.Touch
	lockStoreMockTouch.RUnlock()
	return calls
}
